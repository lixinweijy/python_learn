## 商店系统

### 一.思路

首先要实现增，删，改，查，备份，数据分析与日报功能

把每个功能定义一个函数方便使用，数据分析可以放在日报里面一起，既然可以选择很多功能，就需要一个菜单，并且不能一次操作完就退出，就需要循环使用，既然用到循环，就需要退出功能

所以菜单目录如下:

1.进货

2.售卖

3.修改数据

4.查询数据

5.备份

6.日报

7.退出 (退出功能比较简单，就需要定义一个函数了)



下面为上面功能的简单实现

这里的pass只是占位符的作用，只是为空，不执行任何程序，这里不写任何东西的话会报错，所以使用一个pass

```python
#进货
def plus():
    pass
#售卖
def delete():
    pass
#修改
def modify():
    pass
#查找
def search():
    pass
#备份
def copy():
    pass
#日报
def daily_report():
    pass
#菜单
def menu():
    pass
```



### 二.铺垫

#### 1.goods字典

首先，我定义了一个goods,为字典类型，定义它的作用就是为了来存储每个商品的信息，里面每个键值对以  

**商品号:[商品名,售价,进价]**  

的方式储存，这里的价格都是字符串，为了方便之后的操作。进价我在商品库里没有显示出来，有两个原因，一是因为把进价放在商品库里别人看到了不好，二是因为这个进价是之后加上去的，开始没有规划好，然后也懒得改了，而且按理说商品库也不会让别人看到

这个goods字典里面初始放了四件商品，之后检测到goods字典里没有的商品可以选择手动输入

```python
goods={"9787564182946":["西游记",'49','36'],"9787115503381":["红楼梦",'39','27'],"9787302526896":["三国演义",'75','54'],'9787521316964':["水浒传",'82','65']}
```



#### 2.nums字典

这个字典定义的为一个空字典，可以用来实现商品数量的增加与删减，以如下方式储存

**商品号:数量**  

这个数量是整型的，为了方便后面的加减

```
nums={}
```



#### 3.rb字典

rb字典是用来计算每件商品对应的自处之后的收入的，以如下方式储存

**商品号:盈利**

这个盈利并不是真正意义上的盈利，只是在一次操作中，卖出的收入减去进货的收入，如果进货非常多，就算卖出去的挺多的，这个盈利还是负的

```python
rb={}
```



#### 4.money_pure字典

用来储存每个商品的真实盈利，用它是为了防止之后修改价格后盈利不好计算

```python
money_pure= {}
```

#### 5.初始化仓库

为了仓库美观，先在第一行写一个表头

```python
with open("商品基本库.txt",'w+') as stock:
    stock.write("序号\t\t\t\t商品号\t\t\t\t商品名称\t\t\t\t商品价格\t\t\t\t商品数量\n")
```



### 三.函数实现

#### 1.菜单menu()

因为menu总览了全部，也因为比较好讲，就放在第一个讲

```python
def menu():
    try:
        print("""******************************************************
*******      a.进货      b.售卖      c.修改      ********
*******  d.查询     e.备份     f.日报     q.退出  ********
******************************************************""")
        select=input("请选择你需要执行的任务:\n")
        if select=="a":
            plus()
        elif select=="b":
            delete()
        elif select=="c":
            modify()
            print("退出修改")
        elif select=="d":
            search()
            print("退出查找")
        elif select=="e":
            copy()
        elif select=="q":
            print("谢谢使用")
            return 1
        elif select=="f":
            daily_report()
        else:
            print("输入错误，请重试:\n")
            menu()
    except:
        print("操作有误，再来吧")
        menu()
```

做一个东西给用户的话，我觉得至少不能出现报错的问题，虽然在每个步骤当中都避免了报错的问题，但为了防止有疏漏的地方，就对整体用了个try语句

然后后面就是从菜单中选择一个自己想要实现的功能，运行起来是这样

![image-20220313110750512](https://gitee.com/buguai_lxw/key/raw/master/202203131107561.png)

选择非菜单中的任务时会显示  输入错误，请重试  ，然后再重新运行菜单

注意select中，就是退出那个模块用了个return 1，我的其它条件下都不会有返回值，我们看看没有返回值的函数的布尔值是多少

![image-20220313111335972](https://gitee.com/buguai_lxw/key/raw/master/202203131113025.png)

我们可以清晰的看到是False

这时就先看看最后的主语句

![](https://gitee.com/buguai_lxw/key/raw/master/202203131110004.png)

执行其它的语句都是返回False，结果就是False==False,结果为True，循环继续执行，函数体是pass，前面说过，相当于占位符，当执行 select为q时，return 1，1等于True，然而True不等于False，所以循环结束，程序退出

#### 2.进货 plus()

由于每次进货不会都只进一个货，就需要使用while循环，while循环有一个判断条件，用来判断是否退出进货。之后要输入商品号，如果商品号goods中不存在，则可以选择添加商品信息并买入商品，否则重新输入。

```python
def plus():
    q=1
    while(q!="0"):
        num=input("请输入你需要进货的商品的商品号:\n")
        try:
            statement_1
        except:
            statement_2
        nums[num]=nums.get(num,0)+1
     	tool(num,1)
        """
        进货数量加1
        goods[num].append(1)
        支出
        rb[num]=rb.get(num,0)-int(goods[num][2])
        """
        q=input("是否需要继续进货，退出进货按0\n")
    print("退出进货")
```

statement_1的作用是用来判断goods里是否拥有这个商品，没有就执行statement_2

```python
a=goods.get(num,0)[0]
```

这个a是在后面是没有作用的，这里用它只是因为goods.get(num,0)[0]左边不写点东西的话就会报错，所以这个a写成其它东西也无所谓，这句代码的意义就是从goods中取num的值，如果没有值就返回0，然后0[0]就会报错，然后就进入except，如果不报错就直接运行后面的将件数加1，然后再运行tool(num,1),这个tool的作用就是把数据写入商品库内，先不用管，后面的两条注释的内容前面可以不用管，是日报中需要的



statement_2是用来增加新数据信息的

```python
flag=input("未找到改商品，是否添加数据并进货(添加请输入y):\n")
if flag=="y":
	name = input("请输入商品名称:\n")
    def c(f):
    	try:
        	a=int(input("请输入"+f+":\n"))
            if a>0:
                return a
            print("价格要大于0哦")
            c(f)
        except:
            print("输入的为非法数字，请重新输入")
            c(f)
    price1=str(c("进价"))
    price2=str(c("售价"))
    goods[num] = [name, price2,price1]
else:
    print("再来一次吧")
    continue
```

先说明未找到商品，询问是否添加，不添加就continue，进入下一次循环重新进货了，添加就添加名称，进价和售价到goods字典中，其中价格要大于0，原本想着要售价大于进价，但是因为懒就想着说不定可以清仓大甩卖，进价大于售价也行

![image-20220313103513831](https://gitee.com/buguai_lxw/key/raw/master/202203131035880.png)

大致就是这么个意思



#### 3.售卖delete()

![image-20220313104616834](https://gitee.com/buguai_lxw/key/raw/master/202203131046893.png)

```python
def delete():
    q=1
    while q!="0":
        sale=input("请选择你需要售卖的商品的商品号:\n")
        nums[sale] = nums.get(sale, 0)
        if nums[sale]:
            statement_1
        else:
            print("没货了")
        q=input("是否需要继续售卖，退出售卖按0\n")
    print("退出售卖")
```

循环的套路与进货一致，这边首先是判断是都有这个商品，如果有，num[sale]的值就不是0，否则反之，突然发现进货中的try也可以换成这个



statement_1

```python
            def c():
                try:
                    num = int(input("请输入你要售卖的数量:\n"))
                    if num<=0:
                        a
                    nums[sale]-=num
                    if nums[sale]<0:
                        need=input(f"库存不够了，只有{nums[sale]+num}件啦，全部都要售卖吗?(要则输入y)\n")
                        if need=="y":
                            nums[sale]=0
                            num=nums[sale]+num
                        else:
                            print("那就重新输吧")
                            c()
                    return num
                except:
                    print("要输入合法数字哦，再来一次吧")
                    c()
            num=c()
            print("售卖成功")
            tool(sale,0)
            # rb[sale] = rb.get(sale, 0) + int(goods[sale][1])*num  日报中使用
            # money_pure[sale]=(int(goods[sale][1])-int(goods[sale][2]))*num
```

这个定义c和上面那个一样，是为了防止用户输入非数字而报错的

首先看到第五行，这个a肯定是会报错的，不过只有数量小于0的时候才会执行，接着如果售卖的量大于库存的话，就有两种可能性，一种是删档重来，重输数量，一种是全部买下，之后就会用num存下买的数量。其中数量库里的数量也相应减少了。

下面num=c(）先调用了c返回了一个num值，然后存在了num里面，再利用tool重新再商品基本库里重写那行的数据，注释部分也先不用管，注意每一次改变值了之后nums列表里存的值要改，商品基本库里的也要改



#### 4.修改modiify()

与上面的讨论一样，都是循环加防呆的结构

```python
def modify():
    q=1
    while q!="0":
        def c():
            try:
                modfy=input("请输入你要修改价格的商品的商品号:\n")
                price=input("请输入新价格:\n")
                goods[modfy][1]=price
                if int(price)<0:
                    a
                return modfy
            except:
                print("商品号或者价格输入有误,再来一次吧")
                c()
        tool(c(), 0)
        print("修改成功")
        q = input("是否需要继续修改，退出修改按0\n")
```

这里原本是可以修改价格和名字的，然后觉得一般不会变名字，一个商品号对应一个名字，而且之后日报中也不好弄名字，就把修改名字删掉了

首先看向第8行，如果没有这个商品，goods里面就找不到，就会报错，下一行，这里如果price不能变成整型的话就会报错，变成整型之后小于0也会报错，之后再返回这个商品号，用于tool中在数据库里改变这一行的数据



#### 5.查找search()

 依旧是循环加防呆

```python
def search():
    q=1
    while q!="0":
        choice=input("请选择你要查询的项目:\n[a]显示所有商品信息\t\t[b]按商品号查找商品信息\n")
        if choice=="b":
            select=input("请输入你需要查找的商品号:\n")
            a=goods.get(select,0)
            print("名称:"+a[0]+"\t"+"价格"+a[1]+"元"+"\t\t"+"库存:"+str(nums.get(select,0))) if a else print("未找到该商品")
        elif choice=='a':
            with open("商品基本库.txt", 'r') as search_file:
                print(search_file.read())
        else:
            print("请输入a或者b")
            search()
            break
        q=input("是否退出查找，退出请按0\n")
```

输入a则展示所有商品信息，输入b则按照商品号查找商品信息，这里看向第七行，如果有这个商品则返回商品信息，否则返回0，第八行，用了if a，a没找到就是0，否则不是0，是0就打印未找到，否则打印商品信息

如果输入的非a和b的值就提醒，并重新要求输入



#### 6.备份copy()

这个就比较简单，就是先从商品基本库里读取信息，在存储在以输入的名字的库中去

```python
def copy():
    name=input("请输入你要建立的备份库的名称(不用加后缀):\n")
    with open("商品基本库.txt",'r') as copied_file:
        a=copied_file.read()
        with open(name+".txt","w") as copy_file:
            copy_file.write(a)
    print("备份完成")
```



#### 7.日报

这时就看向最开头的地方

```python
import time
init_time=time.strftime("%Y-%m-%d %H:%M:%S")
```

在程序开始运行时，我先存下来一个时间，在打印日报的时候我又读取了当时的时间

```python
print("********************* 日   报 *************************")
print(f"{init_time}----{last_time}")
```

这就会显示一个这样的东西

![image-20220313134140561](https://gitee.com/buguai_lxw/key/raw/master/202203131341601.png)

这里我赋值了两个变量money和money_pure

money用来显示这次的金额变化，把买东西卖东西的收支都加上去

money_pure1用来存净收入，就是把每件的货物售价减进价的利润加起来

```python
    #单次的收入
    money=0
    #净收入
    money_pure1=0
    #卖出数量z[数量,净收入,名字]
    z=[]
```

z是为了之后显示商品销售情况准备的

```python
lt = list(rb.items())
```

这里rb终于有了用武之地，现在回到上面去看看

进货中的：

![image-20220313143332275](https://gitee.com/buguai_lxw/key/raw/master/202203131433318.png)

**商品号:盈利**

rb的信息是以上形式存在的，所以rb.get(num,0)就相当于原本的盈利，如果原本没有盈利就是0，然后再减去goods中的列表中的第三个值，也就是进价，就得到现在的盈利

再看向售卖中的：

![image-20220313143828759](https://gitee.com/buguai_lxw/key/raw/master/202203131438803.png)

就是用盈利加上售价就是现在的盈利

还有就是售卖中的:

![image-20220313151818795](https://gitee.com/buguai_lxw/key/raw/master/202203131518842.png)

这个money_pure只会在售卖中改变，因为只有卖出去了才会有利润，这个才是真正的利润

它就是用售价减去进价然后乘卖出去的件数，这样就算是改变了价格也是无伤大雅的

最后是进货中的

![image-20220313152611935](https://gitee.com/buguai_lxw/key/raw/master/202203131526981.png)

在goods的值中添加一个1，这个的目的就是记录总共进了多少货，然后nums中有现在有多少货，两个一减就可以得出卖出了多少货，总共记录货的原理就算计算它的长度，用之后的长度减去原本有的三个元素的长度3，就是进价的数目



接下来就是主体部分了：

```python
for i in range(len(lt)):
    statement_1
print(f"总收入为 {money}")
print(f"净收入为 {money_pure1}")
try:
    statement_2
    if money_pure1>200:
        print("收入较大")
    elif money_pure1>100:
        print("收入一般")
    else:
        print("收入微薄")
except:
    print("不行么，一点收支也没有")
```

后面用这try是因为如果什么都不干，直接查看日报的话，statement_2里面的z就是空列表，后面运行就会报错，所以报错的话就说明什么都没有干

首先用了一个for循环，lt是rb字典转化的列表

![image-20220313151001512](https://gitee.com/buguai_lxw/key/raw/master/202203131510561.png)

转化中的元素是元组，元组里的值也是可以通过索引获取的

![image-20220313151125672](https://gitee.com/buguai_lxw/key/raw/master/202203131511721.png)

回归上文，rb中有几个键，lt中就会有几个元素，每个元素代表了一个商品，也就是说，这个的目的就是每次循环处理一个元素。后面就就是把总收入和总净收入打印出来，statement_2和后面的if语句都是用来数据分析的

statement_1

```python
money_pure[lt[i][0]]=money_pure.get(lt[i][0],0)
print("商品"+goods[lt[i][0]][0]+f"卖出{len(goods[lt[i][0]])-3-nums[lt[i][0]]}件，"+f"买入{len(goods[lt[i][0]])-3}件"+f"收入{lt[i][1]}元")
z.append([len(goods[lt[i][0]])-3-nums[lt[i][0]],money_pure[lt[i][0]],goods[lt[i][0]][0]])
money+=lt[i][1]
money_pure1+=money_pure[lt[i][0]]
```

第一行的目的是为了防止出错，因为如果我没有卖出这个商品，而进购了这个商品的话lt中就会多这个数据，从而进入for循环，而money_pure中是没有数据的，这样就会报错，所以首先要把money_pure中没有值的商品添加进去，并把值置为0

lt            		  [(商品号，利润)]

goods     		 {商品号:[书名,售价,进价，……..]}

nums      		 {商品号：最终数目}

money_pure    {商品号:真利润}

这样可以清晰的看见 

```python
goods[lt[i][0]][0]    #商品名
len(goods[lt[i][0]])-3-nums[lt[i][0]]   #卖出件数
len(goods[lt[i][0]])-3    #买入件数
lt[i][1]		#该商品利润
money_pure[lt[i][0]]   #该商品净收入
```

回归上文，第四行就是把每种商品的利润加起来(假利润)

第五行就是把净收入加起来(真利润)

用于后面打印



statement_2

```python
z.sort(key=lambda x:x[0],reverse=True)
print(f"卖的最好的是{z[0][2]},可以多多进货") if z[0][0]>0 else print("商店无人问津")
z.sort(key=lambda x: x[1], reverse=True)
if z[0][1]>0:
	print(f"获益最高的是{z[0][2]},值得进货")
```

第一行是将各商品按照卖出数量排序，然后进行评价

第三行是讲各商品按照净收入进行排列，然后进行评价



#### 8.tool():

这个代码在里面用了三次，分别是在进货，售卖和修改中，其中稍有差别，所以我就定义了一个函数，最后讲是因为我认为我的代码里面就这个难度最高

```python
def tool(num,a):
    with open("商品基本库.txt", 'r+') as stock:
        repete = stock.readlines()
        stock.seek(0)
        if nums[num] > 1 or a==0:
            for i in range(1, len(repete)):
                stock.readline()
                if num in repete[i]:
                    stock.seek(stock.tell())
                    stock.write(" " + str(i) + "\t\t\t" + num + "\t\t\t " + goods[num][0] + "\t\t\t\t " + goods[num][1] + "元\t\t\t\t   " + str(nums[num]))
                    break
        elif a==1:
            stock.write(" " + str(len(stock.readlines())) + "\t\t\t" + num + "\t\t\t " + goods[num][0] + "\t\t\t\t " + goods[num][1] + "元\t\t\t\t   " + str(nums[num]) + "\n")
```

函数中有两个参数，第一个是用来传入商品号的，第二个是用来辨别差别的，然后选择对应的代码，后面就知道了

首先，假如我总共有三行数据，我要修改第二行的价格，或者增加第二行的数量，要怎样做？

我的方法是先把指针移到第二行的开头，然后对第二行进行重新书写

我试了读取第一行的长度，然后用seek去到这个位置的后一个位置，结果是差强人意的，读取出来的东西是这种形式的

![image-20220313174412829](https://gitee.com/buguai_lxw/key/raw/master/202203131744892.png)

一个”\t“可能有时候占一个空，有时候两个，三个，四个，但是读取它的长度的时候就只会读出一个长度

![image-20220313160216169](https://gitee.com/buguai_lxw/key/raw/master/202203131602229.png)

所以这种方法显然不适合

所以我采用的方法就是一行一行读取，读取一行之后判断是否是自己要修改的那行，如果是就修改那行，不是继续读取下一行，没有出现过就直接在最后一行写，没有出现过的情况只会在进货中出现，因为修改和售卖中是在有这个商品的情况下进行的，而进货则不是，这是参数a的重要性就体现出来了

那就只用讨论进货中的情况

先把每一行的信息读取出来以列表的形式存储到repete中，便于之后用来对比是不是自己需要修改的数据

```python
repete = stock.readlines()
stock.seek(0)
if nums[num] > 1 or a==0:
```

然后把指针回归原位

进货这里a为1,只能根据它的数量是否大于1来判断，如果大于1就要重写，否则就在最后一行写

```python
elif a==1:
	stock.write(" " + str(len(stock.readlines())) + "\t\t\t" + num + "\t\t\t " + goods[num][0] + "\t\t\t\t " + goods[num][1] + "元\t\t\t\t   " + str(nums[num]) + "\n")
```

这里的格式与第一行的表头调的是对齐的，最后有一个换行符,序号就读取长度有几行数据的长度，注意这里的序号是用str(len(stock.readlines()))来表示的，而没有用str(len(repete)),虽然上面说了repete=stock.readlines()

![image-20220313184009892](https://gitee.com/buguai_lxw/key/raw/master/202203131840974.png)

![image-20220313184030358](https://gitee.com/buguai_lxw/key/raw/master/202203131840429.png)

就会报错，原因是什么我也还没搞清楚



其余情况就是重写了

```python
for i in range(1, len(repete)):
	stock.readline()
	if num in repete[i]:
		stock.seek(stock.tell())
         stock.write(" " + str(i) + "\t\t\t" + num + "\t\t\t " + goods[num][0] + "\t\t\t\t " + goods[num][1] + "元\t\t\t\t   " + str(nums[num])+"\n")
         break
```

因为repete中第一个元素是表头，这个for循环就从1开始，因为要修改的一行必不可能是表头

首先读一行出来，作用是把指针移到第二行开头，因为每一行有一个换行，所以会跑到下一行去，知道发现这一行是要修改的数据，就重写

这里用到了  in  来判断，repete[i]  是一个字符串，用in来判断这个商品是否在这个字符串中，在的话就重写一遍

然后这样就完成了重写操作



### 四.不足

#### 1.重开

每次都要重开，东西并不能保存下了

解决办法:

应该把那几个字典用txt文件来实现，便于保存,并且以r方式打开文件时应该移动指针去到最后，避免覆盖的问题

#### 2.不便利

进货时可以和售出一样加一个x N，就是可以扫一下，然后输入件数，就可以买多件，还有一个问题就算每进一件货时还要判断一下是否退出，麻烦。

解决方法:

输入商品号的程序可以分为三种模式，因为商品号好像都是13位的，保险起见可以大于10位的就是商品号，把它添加进goods中并进货，小于10000大于0的就是商品数目，n就是退出，第一次输入0到10000以及其它情况就是未定义，没有输入数量就是加1件，连续输入数量就是连续加

#### 3.商品号添加问题

添加商品时商品号可以输入字母上甚至汉字等等

解决办法:

可以用try语句判断一下int(商品号)，如果有错就不是正规商品号就要重新输入

#### 4.日报

可以把日报存到txt文件里面，便于每次信息储存下来

#### 5.美观

报错的方法可以改进一下
