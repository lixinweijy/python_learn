### 三国之谁是话痨

#### 一.结果展示

![image-20220406141641806](https://gitee.com/buguai_lxw/key/raw/master/202204061416892.png)

#### 二.思路

首先整理原文，把原文变成自己想要的样子

再处理新原文



#### 三.原文处理

##### 1.把‘’！“和”？“都换成”。“ 

 因为”！？“在里面也并没有什么用，换成”。“之后可以便于我用正则表达式的一些操作

```python
all_1=all.replace("！","。")
all_2 = all_1.replace("？", "。")
```



##### 2.把第几回以及后面两句话删掉

![image-20220406142109265](https://gitee.com/buguai_lxw/key/raw/master/202204061423322.png)

```python
a_space=re.findall("\n第.*\n",all)
for i in a_space:
    all_2=all_2.replace(i,"\n")
all_3 = all_2.replace("\n", "")
```

不然中间的空格会对接下来的操作产生影响

![20220406140756](https://gitee.com/buguai_lxw/key/raw/master/202204061436856.png)



##### 3.把所有的”前面的除：外都换成。

```python
while all_3.find("\"") != -1:
    if all_3[all_3.find("\"") - 1] != "：" and all_3[all_3.find("\"") - 1] != "。":
        all_3 = all_3[:all_3.find("\"") - 1] + "。" + all_3[all_3.find("\""):]
        all_3 = all_3[:all_3.find("\"")] + "1" + all_3[all_3.find("\"") + 1:]
        all_3 = all_3.replace("1", "\"")
```

先找到“的位置，然后看前面是不是”。“或”：“  不是就把它变成”。“  然后再把”变成1，为了方便find找下一个“，之后改完所有的”在把所有的1变成“就把引号恢复原样了，因为原文原本是没有1的，所以不用担心产生新的问题



##### 4.检查一下

```python
all_speak = re.findall(r'[^。]+：".*?"', all_3)
for i in range(len(all_speak)):
    a = all_speak[i].replace("\"", " ").split()
    if len(a) > 2:
        print(all_speak[i])
```

因为匹配的是从非。的位置到：“”，先把“换成空格，然后再切分的话应该就是两句，是根据第一个冒号切分的，至于换成空格，是因为：

![image-20220406160734606](https://gitee.com/buguai_lxw/key/raw/master/202204061607717.png)



结果以下三句话还是有问题的

![image-20220406161020017](https://gitee.com/buguai_lxw/key/raw/master/202204061610103.png)

这里我就手动把它修改了

```python
c = all_speak[i].find("副将")
d = all_speak[i].find("也：")
e = all_speak[i].find("人")
f = all_speak[i].find("雄，")
if e != -1:
    all_speak[i] = all_speak[i][:e - 1] + "'" + all_speak[i][e:]
if f != -1:
    all_speak[i] = all_speak[i][:f + 1] + all_speak[i][f + 2:f + 5] + "'" + all_speak[i][f + 5:]
if c != -1:
    all_speak[i] = all_speak[i][:c + 2] + "。" + all_speak[i][c + 3:]
if d != -1:
    all_speak[i] = all_speak[i][:d + 1] + "。" + all_speak[i][d + 2:]
```

![image-20220406161143783](https://gitee.com/buguai_lxw/key/raw/master/202204061611873.png)



这样，文档就整理完成了，然后需要把它写入一个新的文件中去

```python
with open("三国演义_1.txt", "w", encoding="utf-8") as w:
    for i in all_speak:
        i = re.findall(r'[^。]+：".*?"',i)
        for j in i:
            w.write(j + "\n")
```

注意，这里原本i已经是一句一句的话了，我还是用了一个正则，就是因为上面三句有问题，还需要改一下，把他们该分开的分开



##### 5.再次检查

这里新创了一个文件，然后读取看看里面每行有没有不是两个引号的，有就打印出来

![image-20220406161639710](https://gitee.com/buguai_lxw/key/raw/master/202204061616874.png)

答案是没有



#### 四.数据统计

##### 1.获取名字清单

这里我是爬取的一个用户的评论

![image-20220406162016996](https://gitee.com/buguai_lxw/key/raw/master/202204061620160.png)

里面的前两组是名和字，但是数据非常的不好看，还需要修改一下

做完又发现了一组好看的，不过没有改

![image-20220406162212740](https://gitee.com/buguai_lxw/key/raw/master/202204061622866.png)

```python
#获取三国中人名与字  存在一个列表里面  以这样的形式[[名,字],[名,字],[名,字],[名,字]]
url="https://zhidao.baidu.com/question/114631954.html"
resp=urllib.request.urlopen(url)
html=resp.read().decode("gbk")
mz=re.findall(r"三国人物大全（魏）.*",html)[0]
mz=re.findall(r"<br />.{10}",mz)
mz.pop(0)
#由于原本信息中每条信息后面还有籍贯之类的，用这个for循环去掉无关紧要的东西，不过有的人名里面没有字，不过无关大雅，因为没有字的都是不出名的
k=[]
for i in range(len(mz)):
    mz[i]=jieba.lcut(mz[i][6:])
    mz[i][1]=mz[i][2]
    while len(mz[i])>2:
        mz[i].pop()
    if ord(mz[i][0][0])<200 or ord(mz[i][0][0])==65288 or len(mz[i][0])==1 or len(mz[i][1])==1:
        k.append(i-len(k))

mz.append(["关羽","云长"])
for i in k:
    mz.pop(i)
```

2到6行是获取数据，后面就是整理数据

这里需要注意的就是删除数据，15,16行，不能直接找到这个数据是你不想要的数据就直接删除，因为那样会改变mz的长度，和后面数据的索引，会导致报错，我这里是先用一个列表把需要删除的元素的索引存下来了，存的方式是i-len(k)，理由和之前一样，我删除的时候会改变后面元素的索引，删一个后面元素的索引就会向前移一，所以前面有几个元素，索引就需要减几。



##### 2.准备工作

```python
zidian={}
num={}
with open("三国演义（原）.txt","r",encoding='utf-8') as f:
    all_1=f.read()
with open("三国演义_1.txt","r",encoding="utf-8") as r:
    all=r.readlines()
```

这里准备了两个字典用来存人物对应的说话句数和说话字数

还分别从原文中和新建文件中获取all_1和all

all是对应的每句话组成的列表

all_1是全文，全文后面用于查找名字需要



##### 3.正文

```python
for i in all:
    d=i.replace('"',' ').split()
    # print(d)
    for k in range(len(mz)):
        if mz[k][0] in d[0] or mz[k][1] in d[0]:#名字都在里面
            zidian[mz[k][0]]=zidian.get(mz[k][0],0)+1
            num[mz[k][0]]=num.get(mz[k][0],0)+len(d[1])
            break
        elif mz[k][0][-1:] in d[0]:#只有名的最后一个字在里面
            tool(mz[k],i,d)
            break
```

显而易见，首先是遍历每一句话，然后再把他们分成两部分(说话者和被说的话)

再利用那些名字在那些说话者中匹配，先匹配他的全名和他的字在不在里面，三国演义的姓名中名都只有一个字，然后一般说缩写的时候都是说的那个字，还有就是说字，比如诸葛亮，他有三种说的可能，一是诸葛亮，二是亮，三是孔明，如果一和三在里面，就添加入两个字典中，break退出这个遍历，否则就看二属不属于，如果二不属与，就下一个名字，如果属于调用tool函数

```python
def tool(a,b,c):
    index_mz = all_1.find(b)
    txt_before = all_1[index_mz- 300:index_mz]
    if a[0] in txt_before or a[1] in txt_before:
        zidian[a[0]]=zidian.get(a[0],0)+1
        num[a[0]]=num.get(a[0],0)+len(c[1])
    elif a[0][-1:] in txt_before:
        tool(a,txt_before,c)
```

这时候需要用all_1了，利用这句话去all_1中 find他的索引，在这个索引前300的位置找看有没有一或三，如果找到了就添加，否则找二，找到了就继续去前300个字，以此类推，直到找到一或三或者找不到二。



##### 4.打印

```python
a=list(zidian.items())
a.sort(key=lambda x:x[1],reverse=True)
print(f"说话句数最多的是:{a[0][0]},共说了{a[0][1]}句话")
b=list(num.items())
b.sort(key=lambda x:x[1],reverse=True)
print(f"说话字数最多的是:{b[0][0]},共说了{b[0][1]}个字")
```

先把字典变成列表，然后再利用降序排列，第一个就是说话句数最多的人和说话字数字数最多的人了。



#### 五.漏洞

##### 1.主语不明

面对这种情况

![image-20220406171723065](https://gitee.com/buguai_lxw/key/raw/master/202204061717207.png)

![image-20220406171823364](https://gitee.com/buguai_lxw/key/raw/master/202204061718493.png)

![image-20220406171841416](https://gitee.com/buguai_lxw/key/raw/master/202204061718503.png)

无法判断主语是谁，会在取那个名字列表中第一个遇到人



##### 2.tool

向前寻找300字，可能那个名字是在别人说的话里面找到的，并不准确

也是会出现名字优先的问题，而且因为是单字，误差很大



##### 3.主语模糊

面对这人说，那人说等情况不给予判断