#coding=gbk
#对类型相似的列表进行整合
s=[[-8,-4,-1,-3,-1,-0,-4,-0,-2,-5,-0,-0,-3,-6,-9,-5,-0,-0,-3,-8,-7,-9,-0,-9,-0,-0],
   [3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,2,3,8,4,6,2,6,4,3,3]]
s1=[['I','Q','R','T','U','V','W','Y','Z'],['q','r','t','u','v','w','y']]#形似列表的整合
s2=[['/','7','8',':',';','<','=','?','@'],['%','&','(',')','*','+','-']]
s3=[['密文','明文'],['明文','密文']]#添加描述用列表。
s4=[-1,1]#这个是判断和使用正负的列表
s5=[['i','z'],['~','1']]#进行单独转换
c=''
pan=eval(input('你是想加密(输入【1】)还是想解密(输入【2】)'))%2
formal=input('请输入你的{}：'.format(s3[pan][0]))

def yunsuan(x,y,q):#和未优化版本一样，对普通的数值进行加密。
    global a       #但是，把相似的几句整合。
    if x<a<y:
        b=a-x
        a=a+s[pan][b-1]
        if pan==1 and a>q :
            a=a-26
        elif pan==0 and a<q:
            a=a+26
#进行普通字符的转换，道理完全相同。
for i in formal:
    a=ord(i)
    if pan==1:#加密解密分开进行，对空间复杂度提升较小的同时，降低了时间复杂度。
        yunsuan(64,91,90)
        yunsuan(96,123,122)
    elif pan==0:
        yunsuan(64,91,65)
        yunsuan(96,123,97)
    a=chr(a)
#对重复字符进行处理。
    f=i
    for ab in range(2):#分别扫描大小写列表,分别进行，与上一个相同。
        for l in range(len(s1[ab])):#遍历识别特殊字符。
            if (f==s1[ab][l] and pan==1) or (f==s2[ab][l] and pan==0):
                f=chr(ord(f)-(26+50*ab)*s4[pan])
                a=f
                break
#单独转换两个小写字母。
    for cd in range(2):
        if i==s5[0][cd] and pan==1:
            a=s5[1][cd]
        elif i==s5[1][cd] and pan==0:
            a=s5[0][cd]
    c=c+a
print('您的{}是：{}'.format(s3[pan][1],c))
